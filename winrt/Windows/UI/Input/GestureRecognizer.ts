// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from Windows 255.255.255.255 at Fri Mar 26 17:23:08 2021
// </auto-generated>
// --------------------------------------------------

import { IVector } from "../../Foundation/Collections/IVector`1";
import { Enumerable } from "../../Foundation/Interop/Enumerable";
import { GenerateShim } from "../../Foundation/Interop/GenerateShim";
import { Point } from "../../Foundation/Point";
import { TypedEventHandler } from "../../Foundation/TypedEventHandler`2";
import { CrossSlideThresholds } from "./CrossSlideThresholds";
import { CrossSlidingEventArgs } from "./CrossSlidingEventArgs";
import { DraggingEventArgs } from "./DraggingEventArgs";
import { GestureSettings } from "./GestureSettings";
import { HoldingEventArgs } from "./HoldingEventArgs";
import { ManipulationCompletedEventArgs } from "./ManipulationCompletedEventArgs";
import { ManipulationInertiaStartingEventArgs } from "./ManipulationInertiaStartingEventArgs";
import { ManipulationStartedEventArgs } from "./ManipulationStartedEventArgs";
import { ManipulationUpdatedEventArgs } from "./ManipulationUpdatedEventArgs";
import { MouseWheelParameters } from "./MouseWheelParameters";
import { PointerPoint } from "./PointerPoint";
import { RightTappedEventArgs } from "./RightTappedEventArgs";
import { TappedEventArgs } from "./TappedEventArgs";

@GenerateShim('Windows.UI.Input.GestureRecognizer')
export class GestureRecognizer { 
    inertiaRotationDeceleration: number = null;
    inertiaRotationAngle: number = null;
    inertiaExpansionDeceleration: number = null;
    inertiaExpansion: number = null;
    gestureSettings: GestureSettings = null;
    crossSlideThresholds: CrossSlideThresholds = null;
    crossSlideHorizontally: boolean = null;
    crossSlideExact: boolean = null;
    autoProcessInertia: boolean = null;
    showGestureFeedback: boolean = null;
    pivotRadius: number = null;
    pivotCenter: Point = null;
    manipulationExact: boolean = null;
    inertiaTranslationDisplacement: number = null;
    inertiaTranslationDeceleration: number = null;
    isActive: boolean = null;
    isInertial: boolean = null;
    mouseWheelParameters: MouseWheelParameters = null;
    canBeDoubleTap(value: PointerPoint): boolean {
        throw new Error('GestureRecognizer#canBeDoubleTap not implemented')
    }
    processDownEvent(value: PointerPoint): void {
        console.warn('GestureRecognizer#processDownEvent not implemented')
    }
    processMoveEvents(value: IVector<PointerPoint>): void {
        console.warn('GestureRecognizer#processMoveEvents not implemented')
    }
    processUpEvent(value: PointerPoint): void {
        console.warn('GestureRecognizer#processUpEvent not implemented')
    }
    processMouseWheelEvent(value: PointerPoint, isShiftKeyDown: boolean, isControlKeyDown: boolean): void {
        console.warn('GestureRecognizer#processMouseWheelEvent not implemented')
    }
    processInertia(): void {
        console.warn('GestureRecognizer#processInertia not implemented')
    }
    completeGesture(): void {
        console.warn('GestureRecognizer#completeGesture not implemented')
    }

    #crossSliding: Set<TypedEventHandler<GestureRecognizer, CrossSlidingEventArgs>> = new Set();
    @Enumerable(true)
    set oncrosssliding(handler: TypedEventHandler<GestureRecognizer, CrossSlidingEventArgs>) {
        this.#crossSliding.add(handler);
    }

    #dragging: Set<TypedEventHandler<GestureRecognizer, DraggingEventArgs>> = new Set();
    @Enumerable(true)
    set ondragging(handler: TypedEventHandler<GestureRecognizer, DraggingEventArgs>) {
        this.#dragging.add(handler);
    }

    #holding: Set<TypedEventHandler<GestureRecognizer, HoldingEventArgs>> = new Set();
    @Enumerable(true)
    set onholding(handler: TypedEventHandler<GestureRecognizer, HoldingEventArgs>) {
        this.#holding.add(handler);
    }

    #manipulationCompleted: Set<TypedEventHandler<GestureRecognizer, ManipulationCompletedEventArgs>> = new Set();
    @Enumerable(true)
    set onmanipulationcompleted(handler: TypedEventHandler<GestureRecognizer, ManipulationCompletedEventArgs>) {
        this.#manipulationCompleted.add(handler);
    }

    #manipulationInertiaStarting: Set<TypedEventHandler<GestureRecognizer, ManipulationInertiaStartingEventArgs>> = new Set();
    @Enumerable(true)
    set onmanipulationinertiastarting(handler: TypedEventHandler<GestureRecognizer, ManipulationInertiaStartingEventArgs>) {
        this.#manipulationInertiaStarting.add(handler);
    }

    #manipulationStarted: Set<TypedEventHandler<GestureRecognizer, ManipulationStartedEventArgs>> = new Set();
    @Enumerable(true)
    set onmanipulationstarted(handler: TypedEventHandler<GestureRecognizer, ManipulationStartedEventArgs>) {
        this.#manipulationStarted.add(handler);
    }

    #manipulationUpdated: Set<TypedEventHandler<GestureRecognizer, ManipulationUpdatedEventArgs>> = new Set();
    @Enumerable(true)
    set onmanipulationupdated(handler: TypedEventHandler<GestureRecognizer, ManipulationUpdatedEventArgs>) {
        this.#manipulationUpdated.add(handler);
    }

    #rightTapped: Set<TypedEventHandler<GestureRecognizer, RightTappedEventArgs>> = new Set();
    @Enumerable(true)
    set onrighttapped(handler: TypedEventHandler<GestureRecognizer, RightTappedEventArgs>) {
        this.#rightTapped.add(handler);
    }

    #tapped: Set<TypedEventHandler<GestureRecognizer, TappedEventArgs>> = new Set();
    @Enumerable(true)
    set ontapped(handler: TypedEventHandler<GestureRecognizer, TappedEventArgs>) {
        this.#tapped.add(handler);
    }

    addEventListener(name: string, handler: any) {
        switch (name) {
            case 'crosssliding':
                this.#crossSliding.add(handler);
                break;
            case 'dragging':
                this.#dragging.add(handler);
                break;
            case 'holding':
                this.#holding.add(handler);
                break;
            case 'manipulationcompleted':
                this.#manipulationCompleted.add(handler);
                break;
            case 'manipulationinertiastarting':
                this.#manipulationInertiaStarting.add(handler);
                break;
            case 'manipulationstarted':
                this.#manipulationStarted.add(handler);
                break;
            case 'manipulationupdated':
                this.#manipulationUpdated.add(handler);
                break;
            case 'righttapped':
                this.#rightTapped.add(handler);
                break;
            case 'tapped':
                this.#tapped.add(handler);
                break;
        }
    }

    removeEventListener(name: string, handler: any) {
        switch (name) {
            case 'crosssliding':
                this.#crossSliding.delete(handler);
                break;
            case 'dragging':
                this.#dragging.delete(handler);
                break;
            case 'holding':
                this.#holding.delete(handler);
                break;
            case 'manipulationcompleted':
                this.#manipulationCompleted.delete(handler);
                break;
            case 'manipulationinertiastarting':
                this.#manipulationInertiaStarting.delete(handler);
                break;
            case 'manipulationstarted':
                this.#manipulationStarted.delete(handler);
                break;
            case 'manipulationupdated':
                this.#manipulationUpdated.delete(handler);
                break;
            case 'righttapped':
                this.#rightTapped.delete(handler);
                break;
            case 'tapped':
                this.#tapped.delete(handler);
                break;
        }
    }
}
