// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from LibWrap 255.255.255.255 at Fri Mar 26 17:24:55 2021
// </auto-generated>
// --------------------------------------------------

import { Binary } from "./Binary";
import { Conversation } from "./Conversation";
import { OnPropertyChangeType } from "./OnPropertyChangeType";
import { VectGIString } from "./VectGIString";
import { VectUnsignedInt } from "./VectUnsignedInt";
import { IClosable } from "winrt/Windows/Foundation/IClosable";
import { Enumerable } from "winrt/Windows/Foundation/Interop/Enumerable";
import { GenerateShim } from "winrt/Windows/Foundation/Interop/GenerateShim";
import { User, PresenceStatus } from "discord.js"
import { PROPKEY } from "./PROPKEY";

@GenerateShim('LibWrap.Contact')
export class Contact implements IClosable {
    static capabilitystatus_CAPABILITY_EXISTS: number = 2;
    static capabilitystatus_CAPABILITY_MIXED: number = 1;
    static capabilitystatus_NO_CAPABILITY: number = 0;
    static capability_CAPABILITY_PUBLIC_CONTACT: number = 14;
    static capability_CAPABILITY_MOBILE_DEVICE: number = 13;
    static capability_CAPABILITY_VOICE_EVER: number = 12;
    static capability_CAPABILITY_TEXT_EVER: number = 11;
    static capability_CAPABILITY_PSTN_TRANSFER: number = 10;
    static capability_CAPABILITY_COMMERCIAL_CONTACT: number = 9;
    static capability_CAPABILITY_LARGE_CONFERENCE: number = 8;
    static capability_CAPABILITY_SERVICE_PROVIDER: number = 7;
    static capability_CAPABILITY_TEXT: number = 6;
    static capability_CAPABILITY_VIDEO: number = 5;
    static capability_CAPABILITY_CALL_FORWARD: number = 4;
    static capability_CAPABILITY_CAN_BE_SENT_VM: number = 3;
    static capability_CAPABILITY_SKYPEIN: number = 2;
    static capability_CAPABILITY_SKYPEOUT: number = 1;
    static capability_CAPABILITY_VOICEMAIL: number = 0;
    static extra_AUTHREQ_FIELDS_SEND_VERIFIED_COMPANY: number = 2;
    static extra_AUTHREQ_FIELDS_SEND_VERIFIED_EMAIL: number = 1;
    static availability_SKYPE_ME_FROM_MOBILE: number = 20;
    static availability_DO_NOT_DISTURB_FROM_MOBILE: number = 18;
    static availability_NOT_AVAILABLE_FROM_MOBILE: number = 17;
    static availability_AWAY_FROM_MOBILE: number = 16;
    static availability_ONLINE_FROM_MOBILE: number = 15;
    static availability_CONNECTING: number = 14;
    static availability_INVISIBLE: number = 6;
    static availability_SKYPE_ME: number = 7;
    static availability_DO_NOT_DISTURB: number = 5;
    static availability_NOT_AVAILABLE: number = 4;
    static availability_AWAY: number = 3;
    static availability_ONLINE: number = 2;
    static availability_OFFLINE_BUT_CF_ABLE: number = 13;
    static availability_OFFLINE_BUT_VM_ABLE: number = 12;
    static availability_OFFLINE: number = 1;
    static availability_SKYPEOUT: number = 10;
    static availability_BLOCKED_SKYPEOUT: number = 11;
    static availability_BLOCKED: number = 9;
    static availability_PENDINGAUTH: number = 8;
    static availability_UNKNOWN: number = 0;
    static authlevel_BLOCKED_BY_ME: number = 2;
    static authlevel_AUTHORIZED_BY_ME: number = 1;
    static authlevel_NONE: number = 0;
    static type_LYNC: number = 9;
    static type_PASSPORT: number = 8;
    static type_XMPP: number = 7;
    static type_EXTERNAL: number = 6;
    static type_UNDISCLOSED_PSTN: number = 5;
    static type_FREE_PSTN: number = 4;
    static type_EMERGENCY_PSTN: number = 3;
    static type_PSTN: number = 2;
    static type_SKYPE: number = 1;
    static type_UNRECOGNIZED: number = 0;

    private user: User;
    constructor(user: User) {
        this.user = user;
    }

    getStrProperty(propKey: number): string {
        for (const key of Object.keys(PROPKEY)) {
            if (PROPKEY[key] == propKey) {
                console.warn("string PROPKEY." + key);
            }
        }

        if (propKey == PROPKEY.contact_SKYPENAME) {
            return `${this.user.username}#${this.user.discriminator}`
        }


        return "";
    }

    getStrPropertyWithXmlStripped(propKey: number): string {
        for (const key of Object.keys(PROPKEY)) {
            if (PROPKEY[key] == propKey) {
                console.warn("string w/o Xml PROPKEY." + key);
            }
        }

        return "";
    }

    getIntProperty(propKey: number): number {
        for (const key of Object.keys(PROPKEY)) {
            if (PROPKEY[key] == propKey) {
                console.warn("int PROPKEY." + key);
            }
        }

        if (propKey == PROPKEY.contact_AVAILABILITY) {
            switch (this.user.presence.status) {
                case "online":
                    return Contact.availability_ONLINE;
                case "dnd":
                    return Contact.availability_DO_NOT_DISTURB;
                case "idle":
                    return Contact.availability_AWAY;
                default:
                    return Contact.availability_OFFLINE;
            }
        }

        return 0;
    }

    getObjectID(): number {
        return parseInt(this.user.id);
    }
    getDbID(): number {
        return parseInt(this.user.id);
    }

    getIdentity(): string {
        return "user_" + this.user.id;
    }

    setExtendedStrProperty(propKey: number, value: string): void {
        console.warn('Contact#setExtendedStrProperty not implemented')
    }
    setExtendedIntProperty(propKey: number, value: number): void {
        console.warn('Contact#setExtendedIntProperty not implemented')
    }
    static typetoString(val: number): string {
        throw new Error('Contact#typetoString not implemented')
    }
    getContactType(): number {
        return Contact.type_SKYPE;
    }
    static authleveltoString(val: number): string {
        throw new Error('Contact#authleveltoString not implemented')
    }
    static availabilitytoString(val: number): string {
        throw new Error('Contact#availabilitytoString not implemented')
    }
    getAvatar(avatar: Binary): boolean {
        throw new Error('Contact#getAvatar not implemented')
    }
    getProfileAttachment(attachmentID: string, attachment: Binary): boolean {
        throw new Error('Contact#getProfileAttachment not implemented')
    }
    getVerifiedEmail(): string {
        throw new Error('Contact#getVerifiedEmail not implemented')
    }
    getVerifiedCompany(): string {
        throw new Error('Contact#getVerifiedCompany not implemented')
    }
    isMemberOf(groupObjectID: number): boolean {
        throw new Error('Contact#isMemberOf not implemented')
    }
    isMemberOfHardwiredGroup(groupType: number): boolean {
        throw new Error('Contact#isMemberOfHardwiredGroup not implemented')
    }
    getUnifiedMasters(masters: VectUnsignedInt): void {
        console.warn('Contact#getUnifiedMasters not implemented')
    }
    getUnifiedServants(servants: VectUnsignedInt): void {
        console.warn('Contact#getUnifiedServants not implemented')
    }
    setBlocked(blocked: boolean, abuse: boolean): boolean {
        throw new Error('Contact#setBlocked not implemented')
    }
    ignoreAuthRequest(): boolean {
        throw new Error('Contact#ignoreAuthRequest not implemented')
    }
    giveDisplayName(name: string): boolean {
        throw new Error('Contact#giveDisplayName not implemented')
    }
    assignSpeedDial(dial: string): boolean {
        throw new Error('Contact#assignSpeedDial not implemented')
    }
    setBuddyStatus(isMyBuddy: boolean, syncAuth: boolean): boolean {
        throw new Error('Contact#setBuddyStatus not implemented')
    }
    static extra_AUTHREQ_FIELDSToString(val: number): string {
        throw new Error('Contact#extra_AUTHREQ_FIELDSToString not implemented')
    }
    sendAuthRequest(message: string, extras_bitmask: number): boolean {
        throw new Error('Contact#sendAuthRequest not implemented')
    }
    hasAuthorizedMe(): boolean {
        return true;
    }
    setPhoneNumber(num: number, label: string, number: string): boolean {
        throw new Error('Contact#setPhoneNumber not implemented')
    }
    copyLocalDataFrom(fromContactObjectID: number): boolean {
        throw new Error('Contact#copyLocalDataFrom not implemented')
    }
    openConversation(conversation: Conversation): boolean {
        throw new Error('Contact#openConversation not implemented')
    }
    static capabilitytoString(val: number): string {
        throw new Error('Contact#capabilitytoString not implemented')
    }
    static capabilitystatustoString(val: number): string {
        throw new Error('Contact#capabilitystatustoString not implemented')
    }
    hasCapability(capability: number, queryServer: boolean): boolean {
        throw new Error('Contact#hasCapability not implemented')
    }
    getCapabilityStatus(capability: number, queryServer: boolean): number {
        throw new Error('Contact#getCapabilityStatus not implemented')
    }
    refreshProfile(): void {
        console.warn('Contact#refreshProfile not implemented')
    }
    getKnownRemoteVersions(versions: VectGIString, useMSNPPresence: boolean): void {
        console.warn('Contact#getKnownRemoteVersions not implemented')
    }
    discard(): void {
        console.warn('Contact#discard not implemented')
    }
    getAuthRequestMessageHtml(): string {
        throw new Error('Contact#getAuthRequestMessageHtml not implemented')
    }
    getDisplayNameHtml(): string {
        return `<b>${this.user.username}</b>#${this.user.discriminator}`;
    }
    getFullNameHtml(): string {
        return `<b>${this.user.username}</b>#${this.user.discriminator}`;
    }
    getMoodTextHtml(): string {
        return ""
    }
    close(): void {
        console.warn('Contact#close not implemented')
    }

    private __propertyChange: Set<OnPropertyChangeType> = new Set();
    @Enumerable(true)
    set onpropertychange(handler: OnPropertyChangeType) {
        this.__propertyChange.add(handler);
    }

    addEventListener(name: string, handler: any) {
        switch (name) {
            case 'propertychange':
                this.__propertyChange.add(handler);
                break;
        }
    }

    removeEventListener(name: string, handler: any) {
        switch (name) {
            case 'propertychange':
                this.__propertyChange.delete(handler);
                break;
        }
    }
}
