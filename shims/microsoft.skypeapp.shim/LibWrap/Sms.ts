// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from LibWrap 255.255.255.255 at Fri Mar 26 17:24:55 2021
// </auto-generated>
// --------------------------------------------------

import { OnPropertyChangeType } from "./OnPropertyChangeType";
import { SmsGetBodyChunksResult } from "./SmsGetBodyChunksResult";
import { SmsSetBodyResult } from "./SmsSetBodyResult";
import { VectGIString } from "./VectGIString";
import { IClosable } from "winrt/Windows/Foundation/IClosable";
import { Enumerable } from "winrt/Windows/Foundation/Interop/Enumerable";
import { GenerateShim } from "winrt/Windows/Foundation/Interop/GenerateShim";

@GenerateShim('LibWrap.Sms')
export class Sms implements IClosable { 
    static confirm_TYPE_ID_SKYPEIN: number = 3;
    static confirm_TYPE_ID_MOBILE: number = 2;
    static confirm_TYPE_ID_SMS: number = 1;
    static setbodyresult_BODY_LASTCHAR_IGNORED: number = 3;
    static setbodyresult_BODY_OK: number = 2;
    static setbodyresult_BODY_TRUNCATED: number = 1;
    static setbodyresult_BODY_INVALID: number = 0;
    static handset_DELIVERY_REPORT_HANDSET_DELIVERY_REPORT_UNKNOWN: number = 2;
    static handset_DELIVERY_REPORT_HANDSET_DELIVERY_REPORT_CAPABLE: number = 1;
    static handset_DELIVERY_REPORT_HANDSET_DELIVERY_REPORT_NOT_CAPABLE: number = 0;
    static cli_USED_CLI_USE_UNKNOWN: number = 2;
    static cli_USED_CLI_CAN_BE_USED: number = 1;
    static cli_USED_CLI_CANNOT_BE_USED: number = 0;
    static reply_CAPABILITY_CAPABLE_LOCALLY: number = 2;
    static reply_CAPABILITY_CAPABLE_GLOBALLY: number = 1;
    static reply_CAPABILITY_NOT_CAPABLE: number = 0;
    static targetstatus_TARGET_DELIVERY_FAILED: number = 7;
    static targetstatus_TARGET_DELIVERY_SUCCESSFUL: number = 6;
    static targetstatus_TARGET_DELIVERY_PENDING: number = 5;
    static targetstatus_TARGET_NOT_ROUTABLE: number = 4;
    static targetstatus_TARGET_ACCEPTABLE: number = 3;
    static targetstatus_TARGET_UNDEFINED: number = 2;
    static targetstatus_TARGET_ANALYZING: number = 1;
    static error_CATEGORY_ERROR_CATEGORY_PERMANENT_SERVICE_ERROR: number = 301;
    static error_CATEGORY_ERROR_CATEGORY_TRANSIENT_SERVICE_ERROR: number = 300;
    static error_CATEGORY_ERROR_CATEGORY_MESSAGE_EXPIRED_BACKEND: number = 201;
    static error_CATEGORY_ERROR_CATEGORY_MESSAGE_EXPIRED_OPERATOR: number = 200;
    static error_CATEGORY_ERROR_CATEGORY_NUMBER_UNREACHABLE: number = 105;
    static error_CATEGORY_ERROR_CATEGORY_NUMBER_BLOCKED: number = 104;
    static error_CATEGORY_ERROR_CATEGORY_NUMBER_DOES_NOT_EXIST: number = 103;
    static error_CATEGORY_ERROR_CATEGORY_DESTINATION_NOT_SUPPORTED: number = 102;
    static error_CATEGORY_ERROR_CATEGORY_INVALID_DST_ADDRESS: number = 101;
    static error_CATEGORY_ERROR_CATEGORY_INVALID_SRC_ADDRESS: number = 100;
    static error_CATEGORY_ERROR_CATEGORY_SMS_VELOCITY_DST_REACHED: number = 19;
    static error_CATEGORY_ERROR_CATEGORY_SYSTEM_ID_BLOCKED: number = 18;
    static error_CATEGORY_ERROR_CATEGORY_BROKEN_DELIVERY_REPORT: number = 17;
    static error_CATEGORY_ERROR_CATEGORY_NO_DELIVERY_REPORT: number = 16;
    static error_CATEGORY_ERROR_CATEGORY_SPAM_DETECTED: number = 15;
    static error_CATEGORY_ERROR_CATEGORY_SPAM_VELOCITY_REACHED: number = 14;
    static error_CATEGORY_ERROR_CATEGORY_SMS_VELOCITY_REACHED: number = 13;
    static error_CATEGORY_ERROR_CATEGORY_SENDER_BLOCKED: number = 12;
    static error_CATEGORY_ERROR_CATEGORY_SENDER_BLOCKED_BY_RECIPIENT: number = 11;
    static error_CATEGORY_ERROR_CATEGORY_RECIPIENT_BLOCKED: number = 10;
    static error_CATEGORY_ERROR_CATEGORY_NO_SENDERID_CAPABILITY: number = 9;
    static error_CATEGORY_ERROR_CATEGORY_NODE_BLOCKED: number = 8;
    static error_CATEGORY_ERROR_CATEGORY_IP_BLOCKED: number = 7;
    static error_CATEGORY_ERROR_CATEGORY_USER_BLOCKED: number = 6;
    static error_CATEGORY_ERROR_CATEGORY_INVALID_CONFIRMATION_CODE: number = 5;
    static error_CATEGORY_ERROR_CATEGORY_INSUFFICIENT_FUNDS: number = 4;
    static error_CATEGORY_ERROR_CATEGORY_NO_SMS_CAPABILITY: number = 3;
    static error_CATEGORY_ERROR_CATEGORY_SERVER_CONNECT_FAILED: number = 2;
    static error_CATEGORY_ERROR_CATEGORY_MISC_ERROR: number = 1;
    static error_CATEGORY_ERROR_CATEGORY_NO_ERROR: number = 0;
    static failurereason_NO_SENDERID_CAPABILITY: number = 9;
    static failurereason_NODE_BLOCKED: number = 8;
    static failurereason_IP_BLOCKED: number = 7;
    static failurereason_USER_BLOCKED: number = 6;
    static failurereason_INVALID_CONFIRMATION_CODE: number = 5;
    static failurereason_INSUFFICIENT_FUNDS: number = 4;
    static failurereason_NO_SMS_CAPABILITY: number = 3;
    static failurereason_SERVER_CONNECT_FAILED: number = 2;
    static failurereason_MISC_ERROR: number = 1;
    static status_FAILED: number = 8;
    static status_SOME_TARGETS_FAILED: number = 7;
    static status_DELIVERED: number = 6;
    static status_SENT_TO_SERVER: number = 5;
    static status_SENDING_TO_SERVER: number = 4;
    static status_COMPOSING: number = 3;
    static status_READ: number = 2;
    static status_RECEIVED: number = 1;
    static outgoing_REPLY_TYPE_REPLY_TYPE_MIXED: number = 4;
    static outgoing_REPLY_TYPE_REPLY_2WAY_AUTOASSIGNED_NR: number = 3;
    static outgoing_REPLY_TYPE_REPLY_USER_PHONE_NR: number = 2;
    static outgoing_REPLY_TYPE_REPLY_SKYPENAME: number = 1;
    static type_CONFIRMATION_CODE_SUBMIT: number = 4;
    static type_CONFIRMATION_CODE_REQUEST: number = 3;
    static type_OUTGOING: number = 2;
    static type_INCOMING: number = 1;
    
    getObjectID(): number {
        throw new Error('Sms#getObjectID not implemented')
    }
    getDbID(): number {
        throw new Error('Sms#getDbID not implemented')
    }
    getStrProperty(propKey: number): string {
        throw new Error('Sms#getStrProperty not implemented')
    }
    getStrPropertyWithXmlStripped(propKey: number): string {
        throw new Error('Sms#getStrPropertyWithXmlStripped not implemented')
    }
    getIntProperty(propKey: number): number {
        throw new Error('Sms#getIntProperty not implemented')
    }
    setExtendedStrProperty(propKey: number, value: string): void {
        console.warn('Sms#setExtendedStrProperty not implemented')
    }
    setExtendedIntProperty(propKey: number, value: number): void {
        console.warn('Sms#setExtendedIntProperty not implemented')
    }
    static typetoString(val: number): string {
        throw new Error('Sms#typetoString not implemented')
    }
    static outgoing_REPLY_TYPEToString(val: number): string {
        throw new Error('Sms#outgoing_REPLY_TYPEToString not implemented')
    }
    static statustoString(val: number): string {
        throw new Error('Sms#statustoString not implemented')
    }
    static failurereasontoString(val: number): string {
        throw new Error('Sms#failurereasontoString not implemented')
    }
    static error_CATEGORYToString(val: number): string {
        throw new Error('Sms#error_CATEGORYToString not implemented')
    }
    static targetstatustoString(val: number): string {
        throw new Error('Sms#targetstatustoString not implemented')
    }
    static reply_CAPABILITYToString(val: number): string {
        throw new Error('Sms#reply_CAPABILITYToString not implemented')
    }
    static cli_USEDToString(val: number): string {
        throw new Error('Sms#cli_USEDToString not implemented')
    }
    static handset_DELIVERY_REPORTToString(val: number): string {
        throw new Error('Sms#handset_DELIVERY_REPORTToString not implemented')
    }
    getTargetStatus(target: string): number {
        throw new Error('Sms#getTargetStatus not implemented')
    }
    getTargetReplyNumber(target: string): string {
        throw new Error('Sms#getTargetReplyNumber not implemented')
    }
    getTargetReplyType(target: string): number {
        throw new Error('Sms#getTargetReplyType not implemented')
    }
    getTargetPrice(target: string): number {
        throw new Error('Sms#getTargetPrice not implemented')
    }
    getTargetCLIUsed(target: string): number {
        throw new Error('Sms#getTargetCLIUsed not implemented')
    }
    getTargetHandsetDeliveryReport(target: string): number {
        throw new Error('Sms#getTargetHandsetDeliveryReport not implemented')
    }
    getTargetErrorCategory(target: string): number {
        throw new Error('Sms#getTargetErrorCategory not implemented')
    }
    canTargetReply(target: string): number {
        throw new Error('Sms#canTargetReply not implemented')
    }
    static setbodyresulttoString(val: number): string {
        throw new Error('Sms#setbodyresulttoString not implemented')
    }
    setReplyTo(number: string): boolean {
        throw new Error('Sms#setReplyTo not implemented')
    }
    setReplyId(callerId: string): boolean {
        throw new Error('Sms#setReplyId not implemented')
    }
    setTargets(numbers: VectGIString): boolean {
        throw new Error('Sms#setTargets not implemented')
    }
    setBody(text: string, chunks: VectGIString): SmsSetBodyResult {
        throw new Error('Sms#setBody not implemented')
    }
    getBodyChunks(textChunks: VectGIString): SmsGetBodyChunksResult {
        throw new Error('Sms#getBodyChunks not implemented')
    }
    send(): boolean {
        throw new Error('Sms#send not implemented')
    }
    setOrigin(origin: string): boolean {
        throw new Error('Sms#setOrigin not implemented')
    }
    static confirm_TYPEToString(val: number): string {
        throw new Error('Sms#confirm_TYPEToString not implemented')
    }
    setConfirmationType(type: number): void {
        console.warn('Sms#setConfirmationType not implemented')
    }
    discard(): void {
        console.warn('Sms#discard not implemented')
    }
    close(): void {
        console.warn('Sms#close not implemented')
    }

    private __propertyChange: Set<OnPropertyChangeType> = new Set();
    @Enumerable(true)
    set onpropertychange(handler: OnPropertyChangeType) {
        this.__propertyChange.add(handler);
    }

    addEventListener(name: string, handler: any) {
        switch (name) {
            case 'propertychange':
                this.__propertyChange.add(handler);
                break;
        }
    }

    removeEventListener(name: string, handler: any) {
        switch (name) {
            case 'propertychange':
                this.__propertyChange.delete(handler);
                break;
        }
    }
}
