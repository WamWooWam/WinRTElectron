// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from Microsoft.Entertainment 255.255.255.255 at Mon Mar 29 16:23:03 2021
// </auto-generated>
// --------------------------------------------------

import { IQuery } from "./IQuery";
import { IQueryChangedEventArgs } from "./IQueryChangedEventArgs";
import { IQueryPage } from "./IQueryPage";
import { IQueryResult } from "./IQueryResult";
import { IServiceXMLQuery } from "./IServiceXMLQuery";
import { RequestType } from "./RequestType";
import { ServiceType } from "./ServiceType";
import { IVectorView } from "winrt/Windows/Foundation/Collections/IVectorView`1";
import { EventHandler } from "winrt/Windows/Foundation/EventHandler`1";
import { IAsyncAction } from "winrt/Windows/Foundation/IAsyncAction";
import { AsyncOperationWithProgress, IAsyncOperationWithProgress } from "winrt/Windows/Foundation/IAsyncOperationWithProgress`2";
import { IClosable } from "winrt/Windows/Foundation/IClosable";
import { Enumerable } from "winrt/Windows/Foundation/Interop/Enumerable";
import { GenerateShim } from "winrt/Windows/Foundation/Interop/GenerateShim";
import { AsyncActionWithProgress } from "winrt/Windows/Foundation/IAsyncActionWithProgress`1";
import { Uri } from "winrt/Windows/Foundation/Uri";

@GenerateShim('Microsoft.Entertainment.Queries.ServiceXMLQuery')
export class ServiceXMLQuery implements IServiceXMLQuery, IQuery, IClosable {
    currentPage: IQueryPage = this;
    nextPage: IQueryPage = null;
    previousPage: IQueryPage = null;
    useIfMatchCache: number = null;
    useCache: number = null;
    uri: string = null;
    serviceType: ServiceType = ServiceType.count;
    requestType: RequestType = RequestType.get;
    pluralizationRules: IVectorView<string> = null;
    forceLowercaseJsonProperties: number = null;
    expirationDate: Date = null;

    _parameters: URLSearchParams = new URLSearchParams();
    _headers: Map<string, string> = new Map();
    _postData: string;
    _postDataType: string;

    addParameter(key: string, value: string): void {
        this._parameters.set(key, value);
    }
    removeParameter(key: string): void {
        this._parameters.delete(key);
    }
    addHeader(key: string, value: string): void {
        this._headers.set(key, value);
    }
    removeHeader(key: string): void {
        this._headers.delete(key);
    }
    setPostData(contentType: string, postData: string): void {
        this._postData = postData;
        this._postDataType = contentType;
    }
    execute() {
        return this.executeAsync();
    }
    executeAsync(): IAsyncOperationWithProgress<IQueryResult, number> {
        return AsyncOperationWithProgress.from(async () => {
            let uri = new Uri(this.uri);
            uri.query = this._parameters.toString();

            let method = this._postData == null ? 'GET' : 'POST';
            let headers = {};
            for (const header of this._headers) {
                headers[header[0]] = header[1];
            }

            if (this._postDataType) {
                headers['Content-Type'] = this._postDataType;
            }

            let resp = await fetch(uri.toString(), {
                method: method,
                headers: headers,
                body: this._postData
            })

            if (!resp.ok)
                throw new Error("Failed to fetch! " + uri);

            return { json: await resp.text() };
        })
    }
    pauseAsync(): IAsyncAction {
        throw new Error('ServiceXMLQuery#pauseAsync not implemented')
    }
    resumeAsync(): IAsyncAction {
        throw new Error('ServiceXMLQuery#resumeAsync not implemented')
    }
    close(): void {
        console.warn('ServiceXMLQuery#close not implemented')
    }
    clearCachedItemsContainingUrlAsync(): IAsyncAction {
        throw new Error('ServiceXMLQuery#clearCachedItemsContainingUrlAsync not implemented')
    }
    testHook_SetXML(value: string): void {
        console.warn('ServiceXMLQuery#testHook_SetXML not implemented')
    }
    testHook_SetDelay(value: number): void {
        console.warn('ServiceXMLQuery#testHook_SetDelay not implemented')
    }

    private __queryChanged: Set<EventHandler<IQueryChangedEventArgs>> = new Set();
    @Enumerable(true)
    set onquerychanged(handler: EventHandler<IQueryChangedEventArgs>) {
        this.__queryChanged.add(handler);
    }

    addEventListener(name: string, handler: any) {
        switch (name) {
            case 'querychanged':
                this.__queryChanged.add(handler);
                break;
        }
    }

    removeEventListener(name: string, handler: any) {
        switch (name) {
            case 'querychanged':
                this.__queryChanged.delete(handler);
                break;
        }
    }
}
