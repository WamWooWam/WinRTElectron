// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from Microsoft.Entertainment 255.255.255.255 at Mon Mar 29 16:23:03 2021
// </auto-generated>
// --------------------------------------------------

import { MediaAvailability } from "../Platform/MediaAvailability";
import { IQuery } from "./IQuery";
import { IQueryChangedEventArgs } from "./IQueryChangedEventArgs";
import { IQueryPage } from "./IQueryPage";
import { IQueryResult } from "./IQueryResult";
import { ITracksQuery } from "./ITracksQuery";
import { TracksQueryCountOperation } from "./TracksQueryCountOperation";
import { TracksSortBy } from "./TracksSortBy";
import { IIterable } from "winrt/Windows/Foundation/Collections/IIterable`1";
import { EventHandler } from "winrt/Windows/Foundation/EventHandler`1";
import { AsyncAction, IAsyncAction } from "winrt/Windows/Foundation/IAsyncAction";
import { AsyncOperationWithProgress, IAsyncOperationWithProgress } from "winrt/Windows/Foundation/IAsyncOperationWithProgress`2";
import { IAsyncOperation } from "winrt/Windows/Foundation/IAsyncOperation`1";
import { IClosable } from "winrt/Windows/Foundation/IClosable";
import { Enumerable } from "winrt/Windows/Foundation/Interop/Enumerable";
import { GenerateShim } from "winrt/Windows/Foundation/Interop/GenerateShim";
import { MediaStore } from "../Platform/MediaStore";
import { DBAlbum, DBArtist, dbPromise, DBGenre, DBTrack } from "../Database/Utils";

// @GenerateShim('Microsoft.Entertainment.Queries.TracksQuery')
export class TracksQuery implements ITracksQuery, IQuery, IClosable {
    watchAll: number = null;
    trackUrl: string = null;
    trackIds: IIterable<number> = null;
    trackId: number = null;
    primarySortBy: TracksSortBy = null;
    pageSize: number = 50;
    mediaAvailability: MediaAvailability = null;
    maxAlbumsCount: number = null;
    keyword: string[] | string;
    groupsEnabled: number = null;
    genreId: number = null;
    artistId: number = null;
    albumId: number = null;
    currentPage: IQueryPage = this;
    get nextPage(): IQueryPage {
        let query = new TracksQuery();
        query.index = this.index + this.pageSize;
        return query;
    }
    get previousPage(): IQueryPage {
        let query = new TracksQuery();
        query.index = Math.min(0, this.index + this.pageSize);
        return query;
    }
    index: number;

    executeAsync(): IAsyncOperationWithProgress<IQueryResult, number> {
        return AsyncOperationWithProgress.from(async () => {
            let instance = MediaStore.instance;
            await AsyncAction.to(instance.ensureDatabaseOpenedAsync());

            let database = instance.database;
            let transaction = database.transaction(['album', 'artist', 'genre', 'track'], 'readonly');
            let albumStore = transaction.objectStore('album');
            let artistStore = transaction.objectStore('artist');
            let genreStore = transaction.objectStore('genre');
            let trackStore = transaction.objectStore('track');
            let tracks = [];
            if (this.albumId) {
                tracks = await dbPromise(trackStore.index('albumId').getAll(this.albumId)) as DBTrack[]
            }
            else {
                tracks = await dbPromise(trackStore.getAll()) as DBTrack[]
            }
            let resultSet = [];
            for (let i = this.index; i < Math.min(this.index + this.pageSize, tracks.length); i++) {
                let track = tracks[i] as DBTrack;
                let album = await dbPromise(albumStore.get(track.albumId)) as DBAlbum;
                let artist = await dbPromise(artistStore.get(track.artistId)) as DBArtist;
                let genre = await dbPromise(genreStore.get(track.genreId)) as DBGenre;

                if (this.keyword && typeof this.keyword == 'string') {
                    if (!track.name.toLowerCase().includes(this.keyword.toLowerCase()))
                        continue;
                }

                if (this.trackUrl) {
                    if (track.filePath !== this.trackUrl)
                        continue;
                }

                resultSet.push({
                    AlbumBingId: "00000000-0000-0000-0000-000000000000",
                    AlbumId: album.id,
                    AlbumImageUrl: track.imageUrl,
                    AlbumName: album.title,
                    AlbumMediaServiceId: "00000000-0000-0000-0000-000000000000",
                    AlbumSortName: album.sortTitle,
                    ArtistBingId: "00000000-0000-0000-0000-000000000000",
                    ArtistCanSmartDJ: false,
                    ArtistCanSmartVJ: false,
                    ArtistId: artist.id,
                    ArtistImageUrl: "",
                    ArtistName: artist.name,
                    ArtistServiceMediaId: "00000000-0000-0000-0000-000000000000",
                    ArtistSortName: artist.sortName,
                    BingId: "00000000-0000-0000-0000-000000000000",
                    CanPlayLocally: true,
                    CatalogId: "00000000-0000-0000-0000-000000000000",
                    CollectionState: 1314,
                    Copyright: "",
                    DateAdded: new Date(Date.now()),
                    DiscNumber: 1,
                    Duration: track.duration,
                    FilePath: `file:///${track.filePath}`,
                    GenreId: track.genreId,
                    GenreName: genre.name,
                    HasBlockedMusicVideo: false,
                    InternalFilesCount: 1,
                    LocalFilesCount: 1,
                    MusicVideoId: "00000000-0000-0000-0000-000000000000",
                    NotInOneDriveCanUpload: true,
                    ObjectId: track.id,
                    OfflineFilesCount: 0,
                    ReleaseDate: track.date,
                    RemoteFilesCount: 0,
                    RemovableFilesCount: 0,
                    RoamingViaCatalog: false,
                    RoamingViaOneDrive: false,
                    ServiceMediaId: "00000000-0000-0000-0000-000000000000",
                    SortTitle: track.name,
                    StarRating: 3,
                    Title: track.name,
                    TrackNumber: track.number
                })
            }

            let result = {
                ResultSet: resultSet,
                TotalCount: tracks.length
            }

            console.log(result);
            return { json: JSON.stringify(result) };
        })
    }
    getCountAsync(): TracksQueryCountOperation {
        throw new Error('TracksQuery#getCountAsync not implemented')
    }
    setCursorPosition(index: number): void {
        this.index = index;
    }
    getGroupsAsync(): IAsyncOperationWithProgress<IQueryResult, number> {
        return AsyncOperationWithProgress.from(async () => {
            let instance = MediaStore.instance;
            await AsyncAction.to(instance.ensureDatabaseOpenedAsync());

            let database = instance.database;
            let transaction = database.transaction(['track'], 'readonly');
            let tracks = await dbPromise(transaction.objectStore('track').getAll()) as DBTrack[];

            let groups = {
                Groups: [{
                    GroupId: "",
                    Name: "",
                    SortName: "",
                    DBOffsetIndex: 0,
                    UIOffsetIndex: 0,
                    ItemsCount: tracks.length,
                    SubGroups: [],
                    ObjectIds: tracks.map((_, i) => i)
                }],
                TotalCount: tracks.length,
                LargestGroupItemsCount: tracks.length
            }

            console.log(groups);

            return { json: JSON.stringify(groups) };
        })
    }
    refreshAsync(): IAsyncAction {
        throw new Error('TracksQuery#refreshAsync not implemented')
    }
    getItemIndexAsync(objectId: number): IAsyncOperation<number> {
        throw new Error('TracksQuery#getItemIndexAsync not implemented')
    }
    execute(): IAsyncOperationWithProgress<IQueryResult, number> {
        throw new Error('TracksQuery#execute not implemented')
    }
    pauseAsync(): IAsyncAction {
        throw new Error('TracksQuery#pauseAsync not implemented')
    }
    resumeAsync(): IAsyncAction {
        throw new Error('TracksQuery#resumeAsync not implemented')
    }
    close(): void {
        console.warn('TracksQuery#close not implemented')
    }

    private __queryChanged: Set<EventHandler<IQueryChangedEventArgs>> = new Set();
    @Enumerable(true)
    set onquerychanged(handler: EventHandler<IQueryChangedEventArgs>) {
        this.__queryChanged.add(handler);
    }

    addEventListener(name: string, handler: any) {
        switch (name) {
            case 'querychanged':
                this.__queryChanged.add(handler);
                break;
        }
    }

    removeEventListener(name: string, handler: any) {
        switch (name) {
            case 'querychanged':
                this.__queryChanged.delete(handler);
                break;
        }
    }
}
