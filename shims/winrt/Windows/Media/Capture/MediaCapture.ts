// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from Windows 255.255.255.255 at Fri Mar 26 17:23:04 2021
// </auto-generated>
// --------------------------------------------------

import { IPropertySet } from "../../Foundation/Collections/IPropertySet";
import { AsyncAction, IAsyncAction } from "../../Foundation/IAsyncAction";
import { IAsyncOperation } from "../../Foundation/IAsyncOperation`1";
import { IClosable } from "../../Foundation/IClosable";
import { Enumerable } from "../../Foundation/Interop/Enumerable";
import { GenerateShim } from "../../Foundation/Interop/GenerateShim";
import { LowLagMediaRecording } from "./LowLagMediaRecording";
import { LowLagPhotoCapture } from "./LowLagPhotoCapture";
import { LowLagPhotoSequenceCapture } from "./LowLagPhotoSequenceCapture";
import { MediaCaptureFailedEventHandler } from "./MediaCaptureFailedEventHandler";
import { MediaCaptureInitializationSettings } from "./MediaCaptureInitializationSettings";
import { MediaCaptureSettings } from "./MediaCaptureSettings";
import { MediaStreamType } from "./MediaStreamType";
import { RecordLimitationExceededEventHandler } from "./RecordLimitationExceededEventHandler";
import { VideoRotation } from "./VideoRotation";
import { AudioDeviceController } from "../Devices/AudioDeviceController";
import { VideoDeviceController } from "../Devices/VideoDeviceController";
import { IMediaExtension } from "../IMediaExtension";
import { IMediaEncodingProperties } from "../MediaProperties/IMediaEncodingProperties";
import { ImageEncodingProperties } from "../MediaProperties/ImageEncodingProperties";
import { MediaEncodingProfile } from "../MediaProperties/MediaEncodingProfile";
import { MediaPropertySet } from "../MediaProperties/MediaPropertySet";
import { IStorageFile } from "../../Storage/IStorageFile";
import { IRandomAccessStream } from "../../Storage/Streams/IRandomAccessStream";

@GenerateShim('Windows.Media.Capture.MediaCapture')
export class MediaCapture implements IClosable { 
    audioDeviceController: AudioDeviceController = null;
    mediaCaptureSettings: MediaCaptureSettings = null;
    videoDeviceController: VideoDeviceController = null;

    initializeAsync(): IAsyncAction {
        return AsyncAction.default();
    }

    initializeWithSettingsAsync(mediaCaptureInitializationSettings: MediaCaptureInitializationSettings): IAsyncAction {
        throw new Error('MediaCapture#initializeWithSettingsAsync not implemented')
    }
    
    startRecordToStorageFileAsync(encodingProfile: MediaEncodingProfile, file: IStorageFile): IAsyncAction {
        throw new Error('MediaCapture#startRecordToStorageFileAsync not implemented')
    }
    startRecordToStreamAsync(encodingProfile: MediaEncodingProfile, stream: IRandomAccessStream): IAsyncAction {
        throw new Error('MediaCapture#startRecordToStreamAsync not implemented')
    }
    startRecordToCustomSinkAsync(encodingProfile: MediaEncodingProfile, customMediaSink: IMediaExtension): IAsyncAction {
        throw new Error('MediaCapture#startRecordToCustomSinkAsync not implemented')
    }
    startRecordToCustomSinkIdAsync(encodingProfile: MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: IPropertySet): IAsyncAction {
        throw new Error('MediaCapture#startRecordToCustomSinkIdAsync not implemented')
    }
    stopRecordAsync(): IAsyncAction {
        throw new Error('MediaCapture#stopRecordAsync not implemented')
    }
    capturePhotoToStorageFileAsync(type: ImageEncodingProperties, file: IStorageFile): IAsyncAction {
        throw new Error('MediaCapture#capturePhotoToStorageFileAsync not implemented')
    }
    capturePhotoToStreamAsync(type: ImageEncodingProperties, stream: IRandomAccessStream): IAsyncAction {
        throw new Error('MediaCapture#capturePhotoToStreamAsync not implemented')
    }
    addEffectAsync(mediaStreamType: MediaStreamType, effectActivationID: string, effectSettings: IPropertySet): IAsyncAction {
        throw new Error('MediaCapture#addEffectAsync not implemented')
    }
    clearEffectsAsync(mediaStreamType: MediaStreamType): IAsyncAction {
        throw new Error('MediaCapture#clearEffectsAsync not implemented')
    }
    setEncoderProperty(mediaStreamType: MediaStreamType, propertyId: string, propertyValue: any): void {
        console.warn('MediaCapture#setEncoderProperty not implemented')
    }
    getEncoderProperty(mediaStreamType: MediaStreamType, propertyId: string): any {
        throw new Error('MediaCapture#getEncoderProperty not implemented')
    }
    setPreviewMirroring(value: boolean): void {
        console.warn('MediaCapture#setPreviewMirroring not implemented')
    }
    getPreviewMirroring(): boolean {
        throw new Error('MediaCapture#getPreviewMirroring not implemented')
    }
    setPreviewRotation(value: VideoRotation): void {
        console.warn('MediaCapture#setPreviewRotation not implemented')
    }
    getPreviewRotation(): VideoRotation {
        throw new Error('MediaCapture#getPreviewRotation not implemented')
    }
    setRecordRotation(value: VideoRotation): void {
        console.warn('MediaCapture#setRecordRotation not implemented')
    }
    getRecordRotation(): VideoRotation {
        throw new Error('MediaCapture#getRecordRotation not implemented')
    }
    startPreviewAsync(): IAsyncAction {
        throw new Error('MediaCapture#startPreviewAsync not implemented')
    }
    startPreviewToCustomSinkAsync(encodingProfile: MediaEncodingProfile, customMediaSink: IMediaExtension): IAsyncAction {
        throw new Error('MediaCapture#startPreviewToCustomSinkAsync not implemented')
    }
    startPreviewToCustomSinkIdAsync(encodingProfile: MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: IPropertySet): IAsyncAction {
        throw new Error('MediaCapture#startPreviewToCustomSinkIdAsync not implemented')
    }
    stopPreviewAsync(): IAsyncAction {
        throw new Error('MediaCapture#stopPreviewAsync not implemented')
    }
    prepareLowLagRecordToStorageFileAsync(encodingProfile: MediaEncodingProfile, file: IStorageFile): IAsyncOperation<LowLagMediaRecording> {
        throw new Error('MediaCapture#prepareLowLagRecordToStorageFileAsync not implemented')
    }
    prepareLowLagRecordToStreamAsync(encodingProfile: MediaEncodingProfile, stream: IRandomAccessStream): IAsyncOperation<LowLagMediaRecording> {
        throw new Error('MediaCapture#prepareLowLagRecordToStreamAsync not implemented')
    }
    prepareLowLagRecordToCustomSinkAsync(encodingProfile: MediaEncodingProfile, customMediaSink: IMediaExtension): IAsyncOperation<LowLagMediaRecording> {
        throw new Error('MediaCapture#prepareLowLagRecordToCustomSinkAsync not implemented')
    }
    prepareLowLagRecordToCustomSinkIdAsync(encodingProfile: MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: IPropertySet): IAsyncOperation<LowLagMediaRecording> {
        throw new Error('MediaCapture#prepareLowLagRecordToCustomSinkIdAsync not implemented')
    }
    prepareLowLagPhotoCaptureAsync(type: ImageEncodingProperties): IAsyncOperation<LowLagPhotoCapture> {
        throw new Error('MediaCapture#prepareLowLagPhotoCaptureAsync not implemented')
    }
    prepareLowLagPhotoSequenceCaptureAsync(type: ImageEncodingProperties): IAsyncOperation<LowLagPhotoSequenceCapture> {
        throw new Error('MediaCapture#prepareLowLagPhotoSequenceCaptureAsync not implemented')
    }
    setEncodingPropertiesAsync(mediaStreamType: MediaStreamType, mediaEncodingProperties: IMediaEncodingProperties, encoderProperties: MediaPropertySet): IAsyncAction {
        throw new Error('MediaCapture#setEncodingPropertiesAsync not implemented')
    }
    close(): void {
        console.warn('MediaCapture#close not implemented')
    }

    #failed: Set<MediaCaptureFailedEventHandler> = new Set();
    @Enumerable(true)
    set onfailed(handler: MediaCaptureFailedEventHandler) {
        this.#failed.add(handler);
    }

    #recordLimitationExceeded: Set<RecordLimitationExceededEventHandler> = new Set();
    @Enumerable(true)
    set onrecordlimitationexceeded(handler: RecordLimitationExceededEventHandler) {
        this.#recordLimitationExceeded.add(handler);
    }

    addEventListener(name: string, handler: any) {
        switch (name) {
            case 'failed':
                this.#failed.add(handler);
                break;
            case 'recordlimitationexceeded':
                this.#recordLimitationExceeded.add(handler);
                break;
        }
    }

    removeEventListener(name: string, handler: any) {
        switch (name) {
            case 'failed':
                this.#failed.delete(handler);
                break;
            case 'recordlimitationexceeded':
                this.#recordLimitationExceeded.delete(handler);
                break;
        }
    }
}
