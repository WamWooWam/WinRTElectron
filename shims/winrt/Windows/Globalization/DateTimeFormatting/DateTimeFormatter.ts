// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from Windows 255.255.255.255 at Fri Mar 26 17:23:03 2021
// </auto-generated>
// --------------------------------------------------

import { IIterable } from "../../Foundation/Collections/IIterable`1";
import { IVectorView } from "../../Foundation/Collections/IVectorView`1";
import { DateTime } from "../../Foundation/DateTime";
import { Enumerable } from "../../Foundation/Interop/Enumerable";
import { GenerateShim } from "../../Foundation/Interop/GenerateShim";
import { ReadOnlyVector } from "../../Foundation/Interop/ReadOnlyVector`1";
import { DayFormat } from "./DayFormat";
import { DayOfWeekFormat } from "./DayOfWeekFormat";
import { HourFormat } from "./HourFormat";
import { MinuteFormat } from "./MinuteFormat";
import { MonthFormat } from "./MonthFormat";
import { SecondFormat } from "./SecondFormat";
import { YearFormat } from "./YearFormat";

// @GenerateShim('Windows.Globalization.DateTimeFormatting.DateTimeFormatter')
export class DateTimeFormatter {

    private static DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    private static SHORT_DAYS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thur', 'Fri', 'Sat'];
    private static MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    private static SHORT_MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

    // hardcoded en_GB >:3
    private static KNWON_FORMATS_TABLE = {
        "month day year": (d: Date) => {
            return `${d.getDate()} ${DateTimeFormatter.MONTHS[d.getMonth()]} ${d.getFullYear()}`
        },
        "year": (d: Date) => {
            return `${d.getFullYear()}`
        },
        "year.full": (d: Date) => {
            return `${d.getFullYear()}`
        },
        "month.abbreviated": (d: Date) => {
            return `${DateTimeFormatter.SHORT_MONTHS[d.getMonth()]}`
        },
        "hour": (d: Date) => {
            return `${d.getHours()}`
        },
        "hour minute": (d: Date) => {
            return `${d.getHours()} ${d.getMinutes()}`
        },
        "hour minute second": (d: Date) => {
            return `${d.getHours()} ${d.getMinutes()} ${d.getSeconds()}`
        },
        "month year": (d: Date) => {
            return `${DateTimeFormatter.MONTHS[d.getMonth()]} ${d.getFullYear()}`
        },
        "day month.full year": (d: Date) => {
            return `${d.getDate()} ${DateTimeFormatter.MONTHS[d.getMonth()]} ${d.getFullYear()}`
        },
        "{dayofweek.full}": (d: Date) => {
            return DateTimeFormatter.DAYS[d.getDay()];
        },
        "dayofweek.full": (d: Date) => {
            return DateTimeFormatter.DAYS[d.getDay()];
        },
        "{dayofweek.abbreviated(3)}": (d: Date) => {
            return DateTimeFormatter.SHORT_DAYS[d.getDay()];
        },
        "shortdate": (d: Date) => {
            return `${d.getDate()}/${d.getMonth()}/${d.getFullYear()}`
        },
        "longdate": (d: Date) => {
            return `${d.getDate()} ${DateTimeFormatter.MONTHS[d.getMonth()]} ${d.getFullYear()}`
        },
        "{dayofweek.abbreviated(2)}, {month.integer}/{day.integer}": (d: Date) => {
            return `${DateTimeFormatter.SHORT_DAYS[d.getDay()]}. ${d.getMonth()}/${d.getDay()}`
        },
        "month.abbreviated year": (d: Date) => {
            return `${DateTimeFormatter.SHORT_MONTHS[d.getMonth()]} ${d.getFullYear()}`
        },
        "{dayofweek.full} {day.integer}": (d: Date) => {
            return `${DateTimeFormatter.DAYS[d.getDay()]} ${d.getDate()}`
        },
        "dayofweek.abbreviated month.abbreviated day": (d: Date) => {
            return `${DateTimeFormatter.SHORT_DAYS[d.getDay()]} ${d.getDate()} ${DateTimeFormatter.SHORT_MONTHS[d.getMonth()]}`
        },
        "dayofweek month day": (d: Date) => {
            return `${DateTimeFormatter.DAYS[d.getDay()]} ${d.getDate()} ${DateTimeFormatter.MONTHS[d.getMonth()]}`
        },
        "dayofweek month day year": (d: Date) => {
            return `${DateTimeFormatter.DAYS[d.getDay()]} ${d.getDate()} ${DateTimeFormatter.MONTHS[d.getMonth()]} ${d.getFullYear()}`
        },
        "{hour.integer(2)}‎:‎{minute.integer(2)}": (d: Date) => {
            return `${d.getHours()} ${d.getMinutes()}`
        },
        "": (d: Date) => {
            return d.toString();
        }
    }

    private formatter: Function;

    numeralSystem: string = null;
    calendar: string = null;
    clock: string = null;
    geographicRegion: string = null;
    includeDay: DayFormat = null;
    includeDayOfWeek: DayOfWeekFormat = null;
    includeHour: HourFormat = null;
    includeMinute: MinuteFormat = null;
    includeMonth: MonthFormat = null;
    includeSecond: SecondFormat = null;
    includeYear: YearFormat = null;
    languages: IVectorView<string> = null;
    resolvedGeographicRegion: string = null;
    resolvedLanguage: string = null;
    template: string = null;

    // constructor(formatTemplate: string);
    // constructor(formatTemplate: string, languages: IIterable<string>);
    // constructor(hourFormat: HourFormat, minuteFormat: MinuteFormat, secondFormat: SecondFormat);
    // constructor(yearFormat: YearFormat, monthFormat: MonthFormat, dayFormat: DayFormat, dayOfWeekFormat: DayOfWeekFormat);
    // constructor(formatTemplate: string, languages: IIterable<string>, geographicRegion: string, calendar: string, clock: string);
    // constructor(yearFormat: YearFormat, monthFormat: MonthFormat, dayFormat: DayFormat, dayOfWeekFormat: DayOfWeekFormat, hourFormat: HourFormat, minuteFormat: MinuteFormat, secondFormat: SecondFormat, languages: IIterable<string>);
    // constructor(yearFormat: YearFormat, monthFormat: MonthFormat, dayFormat: DayFormat, dayOfWeekFormat: DayOfWeekFormat, hourFormat: HourFormat, minuteFormat: MinuteFormat, secondFormat: SecondFormat, languages: IIterable<string>, geographicRegion: string, calendar: string, clock: string);
    constructor(formatTemplate: string) {
        this.template = formatTemplate;
        if (Object.keys(DateTimeFormatter.KNWON_FORMATS_TABLE).includes(formatTemplate)) {
            console.info("new dtf: " + formatTemplate);
            this.formatter = DateTimeFormatter.KNWON_FORMATS_TABLE[formatTemplate];
        }
        else {
            console.warn("unknown dtf: " + formatTemplate);
        }
    }

    @Enumerable(true)
    get patterns(): IVectorView<string> {
        if (this.template === "hour minute")
            return new ReadOnlyVector([ "{hour.integer(2)}‎:‎{minute.integer(2)}" ]);

        return new ReadOnlyVector([this.template]);
    }

    @Enumerable(true)
    static get longDate(): DateTimeFormatter {
        return new DateTimeFormatter("longdate");
    }

    @Enumerable(true)
    static get longTime(): DateTimeFormatter {
        return new DateTimeFormatter("hour minute second");
    }

    @Enumerable(true)
    static get shortDate(): DateTimeFormatter {
        return new DateTimeFormatter("shortdate");
    }

    @Enumerable(true)
    static get shortTime(): DateTimeFormatter {
        return new DateTimeFormatter("hour minute");
    }

    format(value: Date): string {
        let str = this.formatter(value);
        console.log("dtf result: " + str)
        return str;
    }

    formatUsingTimeZone(datetime: Date, timeZoneId: string): string {
        throw new Error('DateTimeFormatter#formatUsingTimeZone not implemented')
    }
}
