// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from Windows 255.255.255.255 at Fri Mar 26 17:23:07 2021
// </auto-generated>
// --------------------------------------------------

import { IAsyncOperation } from "../../Foundation/IAsyncOperation`1";
import { Enumerable } from "../../Foundation/Interop/Enumerable";
import { GenerateShim } from "../../Foundation/Interop/GenerateShim";
import { TypedEventHandler } from "../../Foundation/TypedEventHandler`2";
import { AccessCacheOptions } from "./AccessCacheOptions";
import { AccessListEntryView } from "./AccessListEntryView";
import { IStorageItemAccessList } from "./IStorageItemAccessList";
import { ItemRemovedEventArgs } from "./ItemRemovedEventArgs";
import { IStorageItem } from "../IStorageItem";
import { StorageFile } from "../StorageFile";
import { StorageFolder } from "../StorageFolder";

@GenerateShim('Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList')
export class StorageItemMostRecentlyUsedList implements IStorageItemAccessList { 
    entries: AccessListEntryView = null;
    maximumItemsAllowed: number = null;
    addOverloadDefaultMetadata(file: IStorageItem): string {
        throw new Error('StorageItemMostRecentlyUsedList#addOverloadDefaultMetadata not implemented')
    }
    add(file: IStorageItem, metadata: string): string {
        throw new Error('StorageItemMostRecentlyUsedList#add not implemented')
    }
    addOrReplaceOverloadDefaultMetadata(token: string, file: IStorageItem): void {
        console.warn('StorageItemMostRecentlyUsedList#addOrReplaceOverloadDefaultMetadata not implemented')
    }
    addOrReplace(token: string, file: IStorageItem, metadata: string): void {
        console.warn('StorageItemMostRecentlyUsedList#addOrReplace not implemented')
    }
    getItemAsync(token: string): IAsyncOperation<IStorageItem> {
        throw new Error('StorageItemMostRecentlyUsedList#getItemAsync not implemented')
    }
    getFileAsync(token: string): IAsyncOperation<StorageFile> {
        throw new Error('StorageItemMostRecentlyUsedList#getFileAsync not implemented')
    }
    getFolderAsync(token: string): IAsyncOperation<StorageFolder> {
        throw new Error('StorageItemMostRecentlyUsedList#getFolderAsync not implemented')
    }
    getItemWithOptionsAsync(token: string, options: AccessCacheOptions): IAsyncOperation<IStorageItem> {
        throw new Error('StorageItemMostRecentlyUsedList#getItemWithOptionsAsync not implemented')
    }
    getFileWithOptionsAsync(token: string, options: AccessCacheOptions): IAsyncOperation<StorageFile> {
        throw new Error('StorageItemMostRecentlyUsedList#getFileWithOptionsAsync not implemented')
    }
    getFolderWithOptionsAsync(token: string, options: AccessCacheOptions): IAsyncOperation<StorageFolder> {
        throw new Error('StorageItemMostRecentlyUsedList#getFolderWithOptionsAsync not implemented')
    }
    remove(token: string): void {
        console.warn('StorageItemMostRecentlyUsedList#remove not implemented')
    }
    containsItem(token: string): boolean {
        throw new Error('StorageItemMostRecentlyUsedList#containsItem not implemented')
    }
    clear(): void {
        console.warn('StorageItemMostRecentlyUsedList#clear not implemented')
    }
    checkAccess(file: IStorageItem): boolean {
        throw new Error('StorageItemMostRecentlyUsedList#checkAccess not implemented')
    }

    #itemRemoved: Set<TypedEventHandler<StorageItemMostRecentlyUsedList, ItemRemovedEventArgs>> = new Set();
    @Enumerable(true)
    set onitemremoved(handler: TypedEventHandler<StorageItemMostRecentlyUsedList, ItemRemovedEventArgs>) {
        this.#itemRemoved.add(handler);
    }

    addEventListener(name: string, handler: any) {
        switch (name) {
            case 'itemremoved':
                this.#itemRemoved.add(handler);
                break;
        }
    }

    removeEventListener(name: string, handler: any) {
        switch (name) {
            case 'itemremoved':
                this.#itemRemoved.delete(handler);
                break;
        }
    }
}
