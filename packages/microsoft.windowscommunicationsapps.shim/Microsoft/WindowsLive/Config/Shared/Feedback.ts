// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from Microsoft 255.255.255.255 at Wed Apr 14 20:25:37 2021
// </auto-generated>
// --------------------------------------------------

import { AppId } from "./AppId";
import { IApplication } from "./IApplication";
import { IFeedback } from "./IFeedback";
import { ISupportedMarkets } from "./ISupportedMarkets";
import { IClient } from "../../Platform/IClient";
import { IConfigManager } from "../../Platform/IConfigManager";
import { IMapView } from "winrt/Windows/Foundation/Collections/IMapView`2";
import { IAsyncOperation } from "winrt/Windows/Foundation/IAsyncOperation`1";
import { IClosable } from "winrt/Windows/Foundation/IClosable";
import { AsyncOperation } from "winrt/Windows/Foundation/Interop/AsyncOperation`1";
import { Enumerable } from "winrt/Windows/Foundation/Interop/Enumerable";
import { GenerateShim } from "winrt/Windows/Foundation/Interop/GenerateShim";
import { TypedEventHandler } from "winrt/Windows/Foundation/TypedEventHandler`2";
import { Uri } from "winrt/Windows/Foundation/Uri";
import { IStorageFile } from "winrt/Windows/Storage/IStorageFile";

@GenerateShim('Microsoft.WindowsLive.Config.Shared.Feedback')
export class Feedback implements IFeedback, IClosable { 
    readonly application: IMapView<AppId, IApplication> = null;
    readonly enableFeedback: boolean = null;
    readonly fmsdomain: string = null;
    readonly privacyUrl: string = null;
    readonly supportedMarkets: ISupportedMarkets = null;
    close(): void {
        console.warn('Feedback#close not implemented')
    }
    static loadAsync(obj: any): IAsyncOperation<IFeedback> {
        return AsyncOperation.from(async () => { 
            return new Feedback();
         });
    }
    static loadPlatformAsync(client: IClient): IAsyncOperation<IFeedback> {
        return AsyncOperation.from(async () => { throw new Error('Feedback#loadPlatformAsync not implemented') });
    }
    static loadManagerAsync(manager: IConfigManager): IAsyncOperation<IFeedback> {
        return AsyncOperation.from(async () => { throw new Error('Feedback#loadManagerAsync not implemented') });
    }
    static loadUriAsync(uri: Uri): IAsyncOperation<IFeedback> {
        return AsyncOperation.from(async () => { throw new Error('Feedback#loadUriAsync not implemented') });
    }
    static loadStorageFileAsync(pFile: IStorageFile): IAsyncOperation<IFeedback> {
        return AsyncOperation.from(async () => { throw new Error('Feedback#loadStorageFileAsync not implemented') });
    }
    static loadXmlAsync(xml: string): IAsyncOperation<IFeedback> {
        return AsyncOperation.from(async () => { throw new Error('Feedback#loadXmlAsync not implemented') });
    }
    static loadPlatform(pClient: IClient): IFeedback {
        throw new Error('Feedback#loadPlatform not implemented')
    }
    static loadManager(pManager: IConfigManager): IFeedback {
        throw new Error('Feedback#loadManager not implemented')
    }
    static loadUri(pUri: Uri): IFeedback {
        throw new Error('Feedback#loadUri not implemented')
    }
    static loadStorageFile(pFile: IStorageFile): IFeedback {
        throw new Error('Feedback#loadStorageFile not implemented')
    }
    static loadXml(strXml: string): IFeedback {
        throw new Error('Feedback#loadXml not implemented')
    }

    private __changed: Set<TypedEventHandler<IFeedback, any>> = new Set();
    @Enumerable(true)
    set onchanged(handler: TypedEventHandler<IFeedback, any>) {
        this.__changed.add(handler);
    }

    addEventListener(name: string, handler: any) {
        switch (name) {
            case 'changed':
                this.__changed.add(handler);
                break;
        }
    }

    removeEventListener(name: string, handler: any) {
        switch (name) {
            case 'changed':
                this.__changed.delete(handler);
                break;
        }
    }
}
