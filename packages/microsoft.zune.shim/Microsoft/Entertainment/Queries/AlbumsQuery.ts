// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from Microsoft.Entertainment 255.255.255.255 at Mon Mar 29 16:23:03 2021
// </auto-generated>
// --------------------------------------------------

import { MediaAvailability } from "../Platform/MediaAvailability";
import { AlbumsQueryCountOperation } from "./AlbumsQueryCountOperation";
import { AlbumsSortBy } from "./AlbumsSortBy";
import { IAlbumsQuery } from "./IAlbumsQuery";
import { IQuery } from "./IQuery";
import { IQueryChangedEventArgs } from "./IQueryChangedEventArgs";
import { IQueryPage } from "./IQueryPage";
import { IQueryResult } from "./IQueryResult";
import { IIterable } from "winrt/Windows/Foundation/Collections/IIterable`1";
import { EventHandler } from "winrt/Windows/Foundation/EventHandler`1";
import { AsyncAction, IAsyncAction } from "winrt/Windows/Foundation/IAsyncAction";
import { AsyncOperationWithProgress, IAsyncOperationWithProgress } from "winrt/Windows/Foundation/IAsyncOperationWithProgress`2";
import { IAsyncOperation } from "winrt/Windows/Foundation/IAsyncOperation`1";
import { IClosable } from "winrt/Windows/Foundation/IClosable";
import { Enumerable } from "winrt/Windows/Foundation/Interop/Enumerable";
import { GenerateShim } from "winrt/Windows/Foundation/Interop/GenerateShim";
import { MediaStore } from "../Platform/MediaStore";
import { DBAlbum, DBArtist, dbPromise, DBGenre } from "../Database/Utils";

export interface Groups {
    Groups?: (GroupsEntity)[] | null;
    TotalCount: number;
    LargestGroupItemsCount: number;
}
export interface GroupsEntity {
    GroupId: string;
    Name: string;
    SortName: string;
    ItemsCount: number;
    UIOffsetIndex: number;
    DBOffsetIndex: number;
    SubGroups?: (null)[] | null;
    ObjectIds?: (number)[] | null;
}


@GenerateShim('Microsoft.Entertainment.Queries.AlbumsQuery')
export class AlbumsQuery implements IAlbumsQuery, IQuery, IClosable {
    currentPage: IQueryPage = null;
    nextPage: IQueryPage = null;
    previousPage: IQueryPage = null;
    watchAll: number = null;
    primarySortBy: AlbumsSortBy = null;
    playlistId: number = null;
    pageSize: number = null;
    mediaAvailability: MediaAvailability = null;
    keyword: IIterable<string> = null;
    groupsEnabled: number = null;
    genreId: number = null;
    complexFieldsEnabled: number = null;
    artistId: number = null;
    albumIds: IIterable<number> = null;
    albumId: number = null;
    executeAsync(): IAsyncOperationWithProgress<IQueryResult, number> {
        return AsyncOperationWithProgress.from(async () => {
            let instance = MediaStore.instance;
            await AsyncAction.to(instance.ensureDatabaseOpenedAsync());

            let database = instance.database;
            let transaction = database.transaction(['album', 'artist', 'genre'], 'readonly');
            let artistStore = transaction.objectStore('artist');
            let genreStore = transaction.objectStore('genre');
            let albums = await dbPromise(transaction.objectStore('album').getAll()) as DBAlbum[];
            let resultSet = [];

            for (const album of albums) {
                let genre = await dbPromise(genreStore.get(album.genreIds[0])) as DBGenre;
                let artistNameSet = new Set<String>();
                for (let artistId of album.artistIds) {
                    let artist = await dbPromise(artistStore.get(artistId)) as DBArtist
                    for (let split of artist.name.split(';').map(e => e.split(',')).reduce((acc, cur) => cur.concat(acc), []).filter(e => !!e)) {
                        artistNameSet.add(split.trim())
                    }
                }

                let artistName = [...artistNameSet].join(', ');
                if (artistName.length > 32)
                    artistName = artistName.substr(0, 29) + "...";

                resultSet.push({
                    AlbumArtFileName: album.imageUrl,
                    ArtistBingId: "00000000-0000-0000-0000-000000000000",
                    ArtistCanSmartDJ: false,
                    ArtistCanSmartVJ: false,
                    ArtistId: album.artistIds[0],
                    ArtistImageUrl: "",
                    ArtistName: artistName,
                    ArtistServiceMediaId: "00000000-0000-0000-0000-000000000000",
                    ArtistSortName: artistName,
                    BingId: "00000000-0000-0000-0000-000000000000",
                    CanPlayLocally: true,
                    CollectionState: 1314,
                    DateAdded: album.releaseDate,
                    Description: album.description,
                    GenreId: album.genreIds[0],
                    GenreName: genre.name,
                    ImageUrl: album.imageUrl,
                    InternalTrackCount: album.trackCount,
                    LocalTracksCount: album.trackCount,
                    NotInOneDriveCanUploadTrackCount: album.trackCount,
                    ObjectId: album.id,
                    RecentlyPlayedDate: album.releaseDate,
                    ReleaseDate: album.releaseDate,
                    RemoteTracksCount: 0,
                    RemovableTrackCount: 0,
                    RoamingViaCatalogTrackCount: 0,
                    RoamingViaOneDriveTrackCount: 0,
                    ServiceMediaId: "00000000-0000-0000-0000-000000000000",
                    SortTitle: album.title,
                    Title: album.title,
                    TotalTracksCount: album.trackCount
                });
            }

            let result = {
                ResultSet: resultSet,
                TotalCount: resultSet.length
            }

            console.log(result);
            return { json: JSON.stringify(result) };
        })
    }
    getCountAsync(): AlbumsQueryCountOperation {
        throw new Error('AlbumsQuery#getCountAsync not implemented')
    }
    setCursorPosition(index: number): void {
        console.warn('AlbumsQuery#setCursorPosition not implemented')
    }
    getGroupsAsync(): IAsyncOperationWithProgress<IQueryResult, number> {
        return AsyncOperationWithProgress.from(async () => {
            let instance = MediaStore.instance;
            await AsyncAction.to(instance.ensureDatabaseOpenedAsync());

            let database = instance.database;
            let transaction = database.transaction(['album', 'artist', 'genre'], 'readonly');
            let albums = await dbPromise(transaction.objectStore('album').getAll()) as DBAlbum[];

            let groups: Groups = {
                Groups: [{
                    GroupId: "",
                    Name: "",
                    SortName: "",
                    DBOffsetIndex: 0,
                    UIOffsetIndex: 0,
                    ItemsCount: albums.length,
                    SubGroups: [],
                    ObjectIds: albums.map((_, i) => i)
                }],
                TotalCount: albums.length,
                LargestGroupItemsCount: albums.length
            }

            console.log(groups);

            return { json: JSON.stringify(groups) };
        })
    }
    refreshAsync(): IAsyncAction {
        throw new Error('AlbumsQuery#refreshAsync not implemented')
    }
    getItemIndexAsync(objectId: number): IAsyncOperation<number> {
        throw new Error('AlbumsQuery#getItemIndexAsync not implemented')
    }
    execute(): IAsyncOperationWithProgress<IQueryResult, number> {
        throw new Error('AlbumsQuery#execute not implemented')
    }
    pauseAsync(): IAsyncAction {
        throw new Error('AlbumsQuery#pauseAsync not implemented')
    }
    resumeAsync(): IAsyncAction {
        throw new Error('AlbumsQuery#resumeAsync not implemented')
    }
    close(): void {
        console.warn('AlbumsQuery#close not implemented')
    }

    private __queryChanged: Set<EventHandler<IQueryChangedEventArgs>> = new Set();
    @Enumerable(true)
    set onquerychanged(handler: EventHandler<IQueryChangedEventArgs>) {
        this.__queryChanged.add(handler);
    }

    addEventListener(name: string, handler: any) {
        switch (name) {
            case 'querychanged':
                this.__queryChanged.add(handler);
                break;
        }
    }

    removeEventListener(name: string, handler: any) {
        switch (name) {
            case 'querychanged':
                this.__queryChanged.delete(handler);
                break;
        }
    }
}
