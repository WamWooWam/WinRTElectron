// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from Microsoft.Entertainment 255.255.255.255 at Mon Mar 29 16:23:02 2021
// </auto-generated>
// --------------------------------------------------

import { IDownloadResult } from "./IDownloadResult";
import { IGrovelPastPurchasedMusicResult } from "./IGrovelPastPurchasedMusicResult";
import { IVectorView } from "winrt/Windows/Foundation/Collections/IVectorView`1";
import { EventHandler } from "winrt/Windows/Foundation/EventHandler`1";
import { IAsyncAction } from "winrt/Windows/Foundation/IAsyncAction";
import { AsyncOperation, IAsyncOperation } from "winrt/Windows/Foundation/IAsyncOperation`1";
import { Enumerable } from "winrt/Windows/Foundation/Interop/Enumerable";
import { GenerateShim } from "winrt/Windows/Foundation/Interop/GenerateShim";
import { uuidv4 } from "winrt/Windows/Foundation/Interop/Utils";
import { TracksQuery } from "../Queries/TracksQuery";
import { BASE_URL } from "../Util/EndpointManager";

@GenerateShim('Microsoft.Entertainment.Marketplace.Marketplace')
export class Marketplace {
    static addMedia(serviceMediaIds: string[], mediaTypes: number[], filterToOfferIds: IVectorView<string>, mediaPropertyMap: any, addToCollection: boolean): IAsyncOperation<string> {
        // throw new Error('Marketplace#addMedia not implemented')
        return AsyncOperation.from(async () => "{}");
    }
    static tryAddMedia(serviceMediaIds: IVectorView<string>, mediaTypes: IVectorView<number>, filterToOfferIds: IVectorView<string>, mediaPropertyMap: any, addToCollection: boolean): IAsyncOperation<string> {
        throw new Error('Marketplace#tryAddMedia not implemented')
    }
    static download(ticket: string, mediaIds: IVectorView<number>, mediaTypes: IVectorView<number>, contextMediaId: number, contextMediaTypeId: number, fPreferStandardDef: number): IAsyncOperation<IDownloadResult> {
        throw new Error('Marketplace#download not implemented')
    }

    static getAssetLocationsAsync(ticket: string, serviceMediaIds: string[], mediaInstanceIds: string[], mediaInstanceLicenseRights: number[], fulfillmentTickets: string[], contexts: string[], autoActivateMachine: boolean): IAsyncOperation<string> {
        //throw new Error('Marketplace#getAssetLocationsAsync not implemented')

        return AsyncOperation.from(async () => {
            let assetLocations = {
                results: []
            };

            for (let i = 0; i < serviceMediaIds.length; i++) {
                const serviceMediaId = serviceMediaIds[i];
                const mediaInstanceId = mediaInstanceIds[i];
                const mediaInstanceLicenseRight = mediaInstanceLicenseRights[i];
                const assetUrl = BASE_URL + "/api/fulfillment/track/" + serviceMediaId;

                assetLocations.results.push({
                    assetUrl: assetUrl,
                    mediaInstanceId: mediaInstanceId,
                    nativeLicenceRight: mediaInstanceLicenseRight,
                    offerId: "",
                    trackingId: ""
                });
            }

            return JSON.stringify(assetLocations);
        })
    }

    static getMediaEntitlementsAsync(serviceMediaIds: IVectorView<string>): IAsyncOperation<string> {
        // throw new Error('Marketplace#getMediaEntitlementsAsync not implemented')
        return AsyncOperation.from(async () => {
            let results = {
                entitlements: [],
                counts: {
                    purchased: 0,
                    canFullyDownload: 0,
                    canFullyStream: serviceMediaIds.size,
                    exclusivelyRented: 0
                }
            }

            for (const serviceMediaId of serviceMediaIds) {
                results.entitlements.push({
                    purchase: {
                        stream: { isAvailable: true },
                        download: { isAvailable: true },
                        isAvailable: true
                    },
                    rent: {
                        stream: { isAvailable: true },
                        download: { isAvailable: false },
                        isAvailable: false
                    },
                    hasPurchase: false,
                    canFullyDownload: false
                });
            }

            return JSON.stringify({ result: results })
        });
    }
    static grovelPastPurchasedMusic(historyToken: string, aggressiveGrovel: boolean): IAsyncOperation<IGrovelPastPurchasedMusicResult> {
        throw new Error('Marketplace#grovelPastPurchasedMusic not implemented')
    }
    static sendPlaybackDurationAsync(trackingId: string, duration: number): IAsyncAction {
        throw new Error('Marketplace#sendPlaybackDurationAsync not implemented')
    }
    static purchaseFreeOfferAsync(hbiPassportTicket: string, offerId: string, currencyCode: string): IAsyncAction {
        throw new Error('Marketplace#purchaseFreeOfferAsync not implemented')
    }
    static getAlbumsSuggestAsync(albumLibraryId: number): IAsyncOperation<string> {
        throw new Error('Marketplace#getAlbumsSuggestAsync not implemented')
    }
    static getLatestSeasonMetadataAsync(): IAsyncAction {
        throw new Error('Marketplace#getLatestSeasonMetadataAsync not implemented')
    }
    static generateGuid(): string {
        return uuidv4();
    }

    private static __mediaRightChanged: Set<EventHandler<string>> = new Set();
    @Enumerable(true)
    static set onmediarightchanged(handler: EventHandler<string>) {
        Marketplace.__mediaRightChanged.add(handler);
    }

    static addEventListener(name: string, handler: any) {
        switch (name) {
            case 'mediarightchanged':
                Marketplace.__mediaRightChanged.add(handler);
                break;
        }
    }

    static removeEventListener(name: string, handler: any) {
        switch (name) {
            case 'mediarightchanged':
                Marketplace.__mediaRightChanged.delete(handler);
                break;
        }
    }
}
