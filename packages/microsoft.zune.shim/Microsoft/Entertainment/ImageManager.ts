// --------------------------------------------------
// <auto-generated>
//     This code was generated by tswinrt.
//     Generated from Microsoft.Entertainment 255.255.255.255 at Mon Mar 29 16:23:02 2021
// </auto-generated>
// --------------------------------------------------

import { CopyFileToImageStoreReturnValue } from "./CopyFileToImageStoreReturnValue";
import { IImageCleanupCallback } from "./IImageCleanupCallback";
import { IImageManager } from "./IImageManager";
import { ImageCacheType } from "./ImageCacheType";
import { ImageNamespace } from "./ImageNamespace";
import { ImageResizeMode } from "./ImageResizeMode";
import { ImageSourceFilterFlag } from "./ImageSourceFilterFlag";
import { NetworkUsage } from "./NetworkUsage";
import { ResolutionFallback } from "./ResolutionFallback";
import { AsyncOperation, IAsyncOperation } from "winrt/Windows/Foundation/IAsyncOperation`1";
import { GenerateShim } from "winrt/Windows/Foundation/Interop/GenerateShim";
import { IStorageFile } from "winrt/Windows/Storage/IStorageFile";
import * as fs from 'fs'
import { BASE_URL } from "./Util/EndpointManager";

@GenerateShim('Microsoft.Entertainment.ImageManager')
export class ImageManager implements IImageManager {
    retrieveImageFromUrlAsync(netUsage: NetworkUsage, imageUrl: string, filePath: string, defaultUrl: string): IAsyncOperation<string> {
        console.warn(`retrieveImageFromUrlAsync: ${imageUrl} ${filePath} ${defaultUrl}`)
        return AsyncOperation.from(async () => {
            if (!imageUrl)
                return defaultUrl;

            let response = await fetch(imageUrl);
            if (!response.ok) {
                return defaultUrl;
            }

            let blob = await response.blob();
            return URL.createObjectURL(blob);
        });
    }
    retrieveImageFromBaseUrlAsync(baseImageUrl: string, width: number, height: number, netUsage: NetworkUsage, resolutionFallback: ResolutionFallback, cacheType: ImageCacheType, defaultUrl: string): IAsyncOperation<string> {
        console.warn(`retrieveImageFromBaseUrlAsync: ${baseImageUrl} ${defaultUrl}`)
        return AsyncOperation.from(async () => {
            if (!baseImageUrl)
                return defaultUrl;

            if (fs.existsSync(baseImageUrl))
                return baseImageUrl;

            let response = await fetch(baseImageUrl);
            if (!response.ok) {
                return defaultUrl;
            }

            let blob = await response.blob();
            return URL.createObjectURL(blob);
        });
    }
    retrieveImageForMediaAsync(imageNamespace: ImageNamespace, serviceMediaId: string, width: number, height: number, sourceFilter: ImageSourceFilterFlag, resizeMode: ImageResizeMode, netUsage: NetworkUsage, resolutionFallback: ResolutionFallback, cacheType: ImageCacheType, defaultUrl: string): IAsyncOperation<string> {
        // throw new Error('ImageManager#retrieveImageForMediaAsync not implemented')
        return AsyncOperation.from(async () => BASE_URL + "/api/fulfillment/image/" + serviceMediaId);
    }
    copyFileToImageStoreAsync(file: IStorageFile): IAsyncOperation<CopyFileToImageStoreReturnValue> {
        throw new Error('ImageManager#copyFileToImageStoreAsync not implemented')
    }
    registerImageUrl(imageUrl: string): void {
        console.warn('ImageManager#registerImageUrl not implemented')
    }
    unregisterImageUrl(imageUrl: string): void {
        console.warn('ImageManager#unregisterImageUrl not implemented')
    }
    static initialize(callback: IImageCleanupCallback): void {
        console.warn('ImageManager#initialize not implemented')
    }
    static shutdown(): void {
        console.warn('ImageManager#shutdown not implemented')
    }
}
